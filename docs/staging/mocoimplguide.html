<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Moco: Moco Implementation Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Moco
   </div>
   <div id="projectbrief">Solve optimal control problems with OpenSim models</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Moco Implementation Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#implorg">Organization of classes</a><ul><li class="level2"><a href="#implmocoproblemrep">The MocoProblemRep class</a></li>
</ul>
</li>
<li class="level1"><a href="#impldiverse">Supporting diverse formulations using OpenSim and Simbody</a><ul><li class="level2"><a href="#implkincon">Kinematic constraints</a></li>
<li class="level2"><a href="#implimplicitmultibody">Implicit multibody dynamics</a><ul><li class="level3"><a href="#implimplicitkincon">Implicit multibody dynamics with kinematic constraints</a></li>
</ul>
</li>
<li class="level2"><a href="#implpreskin">Prescribed kinematics</a><ul><li class="level3"><a href="#implpreskinkincon">Prescribed kinematics with kinematic constraints</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><br />
 This guide explains the organization of code in Moco and how direct collocation schemes are implemented using an OpenSim model.</p>
<h1><a class="anchor" id="implorg"></a>
Organization of classes</h1>
<p>Moco is organized as pairs of Problem and Solver classes.</p>
<div class="image">
<object type="image/svg+xml" data="MocoImplementationDiagram.svg" width="700px">MocoImplementationDiagram.svg</object>
</div>
<p>Figure: Organization of classes in Moco. Abstract classes are denoted by dashed lines.</p>
<p><a class="el" href="class_open_sim_1_1_moco_problem.html" title="A description of an optimal control problem, backed by OpenSim Models. ">MocoProblem</a> describes a direct collocation problem using an OpenSim Model, and <a class="el" href="class_open_sim_1_1_moco_solver.html" title="Once the solver is created, you should not make any edits to the MocoProblem. ">MocoSolver</a> is an abstract class for solving MocoProblems. Moco provides two MocoSolvers: <a class="el" href="class_open_sim_1_1_moco_tropter_solver.html" title="Solve the MocoProblem using the tropter direct collocation library. ">MocoTropterSolver</a> and <a class="el" href="class_open_sim_1_1_moco_cas_a_di_solver.html" title="This solver uses the CasADi library (https://casadi.org) to convert the MocoProblem into a generic no...">MocoCasADiSolver</a>. <a class="el" href="class_open_sim_1_1_moco_tropter_solver.html" title="Solve the MocoProblem using the tropter direct collocation library. ">MocoTropterSolver</a> contains a problem-solver pair for optimal control problems: TropterProblem (which derives from <a class="el" href="classtropter_1_1_problem.html">tropter::Problem</a>) and tropter::DirectCollocation. To solve the optimal control problem, tropter::DirectCollocation employs a problem-solver pair for generic nonlinear optimization: tropter::Transcription (which derives from tropter::optimization::Problem) and tropter::optimization::Solver. The <a class="el" href="class_open_sim_1_1_moco_cas_a_di_solver.html" title="This solver uses the CasADi library (https://casadi.org) to convert the MocoProblem into a generic no...">MocoCasADiSolver</a> employs the problem-solver pair of <a class="el" href="class_open_sim_1_1_moco_cas_o_c_problem.html">MocoCasOCProblem</a> (deriving from <a class="el" href="class_cas_o_c_1_1_problem.html">CasOC::Problem</a>) and <a class="el" href="class_cas_o_c_1_1_solver.html" title="Once you have built your CasOC::Problem, create a CasOC::Solver to configure how you want to solve th...">CasOC::Solver</a>.</p>
<p>These pairs of classes allow a separation between how a user specifies a problem and the method used to solve the problem. The <a class="el" href="class_open_sim_1_1_moco_problem.html" title="A description of an optimal control problem, backed by OpenSim Models. ">MocoProblem</a> class contains only user input and describes the physical optimal control problem. The <a class="el" href="class_open_sim_1_1_moco_solver.html" title="Once the solver is created, you should not make any edits to the MocoProblem. ">MocoSolver</a> classes allow the user to configure the numerical method used to solve the problem.</p>
<h2><a class="anchor" id="implmocoproblemrep"></a>
The MocoProblemRep class</h2>
<p>The <a class="el" href="class_open_sim_1_1_moco_solver.html" title="Once the solver is created, you should not make any edits to the MocoProblem. ">MocoSolver</a> interacts with the <a class="el" href="class_open_sim_1_1_moco_problem.html" title="A description of an optimal control problem, backed by OpenSim Models. ">MocoProblem</a> through the intermediate class <a class="el" href="class_open_sim_1_1_moco_problem_rep.html" title="The primary intent of this class is for use by MocoSolvers, but users can also use this class to appl...">MocoProblemRep</a>. This class exists to:</p>
<ol type="1">
<li>Validate the <a class="el" href="class_open_sim_1_1_moco_problem.html" title="A description of an optimal control problem, backed by OpenSim Models. ">MocoProblem</a> and cache useful quantities.</li>
<li>Provide functionality, such as evaluating cost terms.</li>
<li>Prevent solvers from accidentally editing any user input; the solvers do not have access to the original <a class="el" href="class_open_sim_1_1_moco_problem.html" title="A description of an optimal control problem, backed by OpenSim Models. ">MocoProblem</a>.</li>
</ol>
<p>The <a class="el" href="class_open_sim_1_1_moco_problem_rep.html" title="The primary intent of this class is for use by MocoSolvers, but users can also use this class to appl...">MocoProblemRep</a> allows us not to worry about using invalid caches. Every time the Solver solves a problem, a new <a class="el" href="class_open_sim_1_1_moco_problem_rep.html" title="The primary intent of this class is for use by MocoSolvers, but users can also use this class to appl...">MocoProblemRep</a> is created, ensuring that the most up-to-date settings in <a class="el" href="class_open_sim_1_1_moco_problem.html" title="A description of an optimal control problem, backed by OpenSim Models. ">MocoProblem</a> are obeyed.</p>
<h1><a class="anchor" id="impldiverse"></a>
Supporting diverse formulations using OpenSim and Simbody</h1>
<p>The following problem formulations in Moco require careful consideration:</p>
<ol type="1">
<li>kinematic constraints,</li>
<li>expressing multibody dynamics as implicit differential equations, and</li>
<li>prescribing kinematics.</li>
</ol>
<p>We'll describe how Moco handles each of these formulations.</p>
<p>There are multiple ways to use a SimTK::System to compute desired quantities. SimTK::SimbodyMatterSubsystem contains many useful operators, but the conventional way to use a SimTK::System is to realize the system's SimTK::State through the Position, Velocity, Dynamics, and Acceleration stages. Using the SimTK::System in this way ensures that all calculations use the same input variables; this is described more concretely later. While the three formulations above could more easily be achieved using the SimTK::SimbodyMatterSubsystem operators, we employ strategies to handle these formulations using the standard realization stages. The goal of the following sections is to explain how we work the formulations above into the realization stages.</p>
<h2><a class="anchor" id="implkincon"></a>
Kinematic constraints</h2>
<p>When performing musculoskeletal simulations, we must satisfy the following equations for the multibody dynamics, kinematic constraints, and auxiliary dynamics (in that order):</p>
<p class="formulaDsp">
\[ \begin{alignat*}{2} M(q, p)\dot{u} + G(q, p)^T \lambda &amp;= f_{\textrm{app}}(t, y, x, p) - f_{\textrm{bias}}(q, u, p) \\ 0 &amp;= \phi(q, p) \\ \dot{z}(t) &amp;= f_{\textrm{aux}}(t, y, x, \lambda, p). \\ \end{alignat*} \]
</p>
<p>The common way to solve these equations is to differentiate the kinematic constraints until generalized accelerations appear linearly, and then solve for generalized accelerations and Lagrange multipliers. This calculation occurs when realizing a SimTK::System to SimTK::Stage::Acceleration.</p>
<p class="formulaDsp">
\[ \begin{alignat*}{2} \begin{bmatrix} M(q, p) &amp; G(q, p)^T \\ G(q, p) &amp; 0 \end{bmatrix} \begin{bmatrix} \dot{u} \\ \lambda \end{bmatrix} &amp;= \begin{bmatrix} f_{\textrm{app}}(t, y, x, p) - f_{\textrm{bias}}(q, u, p) \\ b(q, u) \end{bmatrix} \\ \dot{z}(t) &amp;= f_{\textrm{aux}}(t, y, x, \lambda, p) \\ \end{alignat*} \]
</p>
<p>Simbody then integrates \( u \) and \( z \) using the \( \dot{u} \) and \( \dot{z} \) calculated from the equations above. If the kinematic constraints are obeyed in the initial state, then theoretically, enforcing the constraints at the acceleration level (as done above) should cause the accelerations to remain enforced at the position and velocity levels. However, numerical integrators generate errors, causing the constraints to no longer be satisfied at the position and velocity levels. To fix this, Simbody projects the generalized coordinates and speeds onto the "constraint manifold" (that is, the multidimensional surface on which the system's kinematic constraints are satisfied; see SimTK::System::project()).</p>
<p>Handling kinematic constraints in direct collocation requires a different approach, because we cannot perform an internal "projection" within the direct collocation optimization problem. We use the method developed by Posa et al. [1]. In this scheme, the optimization solver searches for Lagrange multipliers that satisfy the equations above. This means that, when we use Simbody to evaluate multibody equations, we must tell Simbody what multipliers to use. However, this flow of data does not fit with Simbody's realization scheme, in which Simbody computes Lagrange multipliers itself. Some quantities such as joint reaction loads depend on Lagrange multipliers, and it is essential that we use the correct multipliers when computing such quantities (that is, the multipliers from the optimization instead of those computed by Simbody). To circumvent this issue, we employ two OpenSim Models: the original user-provided model with kinematic constraints, and a model in which all kinematic constraints are disabled. We use the first (constrained) model to calculate kinematic constraint violations and to convert the optimization solver's Lagrange multipliers into body and mobilizer forces using the constrained model's constraint Jacobian. Then we apply the multiplier-derived forces to the unconstrained model using the <a class="el" href="class_open_sim_1_1_discrete_forces.html" title="This class is a thin wrapper to Simbody&#39;s SimTK::Force::DiscreteForces class. ">DiscreteForces</a> component. In <a class="el" href="class_open_sim_1_1_moco_goal.html" title="A term in the cost functional, to be minimized. ">MocoGoal</a> and <a class="el" href="class_open_sim_1_1_moco_path_constraint.html" title="A path constraint to be enforced in the optimal control problem. ">MocoPathConstraint</a>, we provide the unconstrained model with applied multiplier-derived forces, ensuring that joint reaction load calculations will use the correct multipliers.</p>
<p>Note that MocoGoals and MocoPathConstraints do not have direct access to the Lagrange multipliers; the unconstrained model does not have multipliers.</p>
<h2><a class="anchor" id="implimplicitmultibody"></a>
Implicit multibody dynamics</h2>
<p>When enforcing multibody dynamics using an implicit differential equation, we do not solve explicitly for \( \dot{u} \). Instead, \( \dot{u} \) is a variable in the optimal control problem and the optimizer searches for the value of \( \dot{u} \) that satisfies the multibody dynamics equation in its original form. This is similar to the "inverse dynamics" calculation, in which one knows \( \dot{u} \) and solves for the additional generalized forces (mobility forces) required for the multibody dynamics equation to hold:</p>
<p class="formulaDsp">
\[ f_{\mathrm{residual}} = M \dot{u} + f_{\mathrm{bias}} - f_{\mathrm{app}}. \]
</p>
<p>Simbody provides the SimTK::SimbodyMatterSubsystem::calcResidual() "inverse
dynamics" operator to compute this residual force, and we could use this residual force in a path constraint to enforce multibody dynamics implicitly. However, the accelerations computed by realizing to SimTK::Stage::Acceleration (e.g., when computing a joint reaction load for a cost term) are different from the acceleration values we receive from the optimizer to perform calcResidual(). Therefore, we use an alternate scheme: we use SimTK::Motion to prescribe generalized accelerations, using the <a class="el" href="class_open_sim_1_1_acceleration_motion.html" title="This class is a thin wrapper to Simbody&#39;s SimTK::Motion for prescribing the acceleration of all degre...">AccelerationMotion</a> component. The SimTK::Motion comes with motion Lagrange multipliers \( \lambda_m \) that, when realizing to SimTK::Stage::Acceleration, are set to be the forces required for multibody dynamics to hold.</p>
<p class="formulaDsp">
\[ M \dot{u} + f_{\mathrm{bias}} + \lambda_m = f_{\mathrm{app}}. \]
</p>
<p>That is, the motion multipliers are equivalent to the residual forces from calcResidual().</p>
<p>To enforce multibody dynamics, we use a path constraint to enforce the motion multipliers to be 0; that is, the force elements in the model must generate the forces necessary to satisfy the equations of motion.</p>
<h3><a class="anchor" id="implimplicitkincon"></a>
Implicit multibody dynamics with kinematic constraints</h3>
<p>With kinematic constraints, the equations of motion contain both kinematic constraint Lagrange multipliers \( \lambda_c \) and motion Lagrange multpliers \( \lambda_m \):</p>
<p class="formulaDsp">
\[ M(q)\dot{u} + f_{\textrm{bias}}(q, u) + G(q)^T \lambda_c + \lambda_m = f_{\textrm{app}}(t, q, u, z, x). \]
</p>
<p>Handling kinematic constraints with implicit multibody dynamics is no different than how kinematic constraints are handled with explicit multibody dynamics. The optimization solver still has variables for the Lagrange multipliers and we enforce kinematic constraints as path constraints in the optimal control problem.</p>
<h2><a class="anchor" id="implpreskin"></a>
Prescribed kinematics</h2>
<p>The situation of prescribed kinematics is similar to the situation for implicit multibody dynamics. In both cases, we are prescribing some portion of kinematics into the SimTK::System. For implicit dynamics, we are prescribing accelerations, and updating these accelerations with each optimization iteration. For prescribed kinematics, we prescribe coordinates, speeds, and accelerations based on user input. Given the similarity, we again use SimTK::Motion, but this time we enforce the motion at the position level using the <a class="el" href="class_open_sim_1_1_position_motion.html" title="This class prescribes the value, speed, and acceleration of all coordinates in the model using SimTK:...">PositionMotion</a> component. No constraints are added (unlike with the prescribed_function property of OpenSim::Coordinate); instead, variables are replaced with data.</p>
<p>For a system without kinematic constraints, the equations of motion are:</p>
<p class="formulaDsp">
\[ M(\hat{q})\dot{\hat{u}} + f_{\textrm{bias}}(\hat{q}, \hat{u}) + \lambda_m = f_{\textrm{app}}(t, \hat{q}, \hat{u}, z, x) \\ \]
</p>
<p>The hat denotes known quantities; the only variables are \( z \) and \( x \).</p>
<p>The Lagrange multipliers \( \lambda_m \) are the mobility forces required for the system to follow the prescribed kinematics. In our case, we do not want any ficticious forces generated, and so we require that \(\lambda_m = 0\). Simbody gives us access to these multipliers via SimTK::SimbodyMatterSubsystem::findMotionForces(), and we constrain the output of this function to be 0. Note that the only unknown in this equation is \( f_{\mathrm{app}} \); the other quantities are known because they only depend on kinematics. We enforce the equations of motion as path constraints, but there are no multibody states or defects in the optimal control problem.</p>
<p>Combining prescribed kinematics with implicit multibody dynamics is not possible: when kinematics are prescribed, there are no multibody dynamics to enforce. We only add the <a class="el" href="class_open_sim_1_1_acceleration_motion.html" title="This class is a thin wrapper to Simbody&#39;s SimTK::Motion for prescribing the acceleration of all degre...">AccelerationMotion</a> component to the model if the model does not contain a <a class="el" href="class_open_sim_1_1_position_motion.html" title="This class prescribes the value, speed, and acceleration of all coordinates in the model using SimTK:...">PositionMotion</a>.</p>
<h3><a class="anchor" id="implpreskinkincon"></a>
Prescribed kinematics with kinematic constraints</h3>
<p>With kinematic constraints, the equations of motion are</p>
<p class="formulaDsp">
\[ M(\hat{q})\dot{\hat{u}} + f_{\textrm{bias}}(\hat{q}, \hat{u}) + G(\hat{q})^T \lambda_c + \lambda_m = f_{\textrm{app}}(t, \hat{q}, \hat{u}, z, x) \\ \]
</p>
<p>\( G \) is the kinematic constraint Jacobian and \( \lambda_c \) are the kinematic constraint Lagrange multipliers. We still require \( \lambda_m = 0 \) but we must allow the kinematic constraints to apply forces. Applied forces affect what the constraint forces must be. Consider a point mass with degrees of freedom \( x \) and \( y \) and generalized forces \( F_x \) and \( F_y \) constrained to the line \( y = x \) and with prescribed motion \( y(t) = x(t) = \sin(t) \). Moco will solve for the forces \( F_x \) and \( F_y \) that can achieve this prescribed motion (by setting \( \lambda_m = 0 \) and solving for \( f_{\mathrm{app}} \), and the Lagrange multiplier \( \lambda_c \) will ensure that, regardless of the values of \( F_x \) and \( F_y \), the mass will remain on the line.</p>
<p>In this scenario, we do not include path constraints for the kinematic constraint errors: the generalized coordinates, speeds, and accelerations are no longer variables in the problem, and so the constraint errors are constant.</p>
<p>[1] M. Posa, S. Kuindersma, and R. Tedrake, “Optimization and stabilization of trajectories for constrained dynamical systems,” in Proceedings of the International Conference on Robotics and Automation (ICRA), Stockholm, Sweden, 2016. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jul 15 2019 20:51:08 for Moco by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
